---
layout:     post
title:      "03丨消息模型"
date:       2019-11-11 17:58:05
author:     "jiefang"
header-style: text
tags:
    - 消息中间件
---
# 03丨消息模型
## 主题和队列的区别
### 队列模型
队列是先进先出（FIFO, First-In-First-Out）的线性表（Linear List）。在具
体应用中通常用链表或者数组来实现。队列只允许在后端（称为 rear）进行
插入操作，在前端（称为 front）进行删除操作。

这个定义里面包含几个关键点，第一个是先进先出，这里面隐含着的一个要求是，在消息入队出队过程中，需要保证这些消息**严格有序**，按照什么顺序写进队列，必须按照同样的顺序从队列中读出来。不过，队列是没有“读”这个操作的，“读”就是出队，也就是从队列中“删除”这条消息。

早期的消息队列，就是按照“队列”的数据结构来设计的。

![队列模型](https://s2.ax1x.com/2019/10/27/Ky6kdJ.png)

## 发布-订阅模型
在发布 - 订阅模型中，消息的发送方称为发布者（Publisher），消息的接收方称为订阅者（Subscriber），服务端存放消息的容器称为主题（Topic）。发布者将消息发送到主题中，订阅者在接收消息之前需要先“订阅主题”。“订阅”在这里既是一个动作，同时还可以认为是主题在消费时的一个逻辑副本，每份订阅中，订阅者都可以接收到主题的所有消息。

对比这两种模型，生产者就是发布者，消费者就是订阅者，队列就是主题，并没有本质的区别。**它们最大的区别其实就是，一份消息数据能不能被消费多次的问题**
![发布-订阅模型](https://s2.ax1x.com/2019/10/27/KygGxP.png)
## RabbitMQ 的消息模型
RabbitMQ是少数依然坚持使用队列模型的产品之一。那它是怎么解决
多个消费者的问题呢？在RabbitMQ中，Exchange位于生产者和队列之间，生产者并不关心将消息发送给哪个队列，而是将消息发送给 Exchange，由 Exchange 上配置的策略来决定将消息投递到哪些队列中。
![RabbitMQ 的消息模型](https://s2.ax1x.com/2019/10/27/KygcrT.png)
同一份消息如果需要被多个消费者来消费，需要配置Exchange将消息发送到多个队列，每个队列中都存放一份完整的消息数据，可以为一个消费者提供消费服务。这也可以变相地实现新发布-订阅模型中，“一份消息数据可以被多个订阅者来多次消费”这样功能。
## RocketMQ 的消息模型
RocketMQ 使用的消息模型是标准的发布 - 订阅模型，在 RocketMQ 也有队列（Queue）这个概念。

每个主题包含多个队列，通过多个队列来实现多实例并行生产和消费。需要注意的是，RocketMQ 只在队列上保证消息的有序性，主题层面是无法保证消息的严格顺序的。
### 消费组
RocketMQ 中，订阅者的概念是通过消费组（ConsumerGroup）来体现的。每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被 Consumer Group1 消费过，也会再给 Consumer Group2 消费。

消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。如果一条消息被消费者Consumer1消费了，那同组的其他消费者就不会再收到这条消息
### 消费位置
在 Topic 的消费过程中，由于消息需要被不同的组进行多次消费，所以消费完的消息并不会立即被删除，这就需要RocketMQ为每个消费组在每个队列上维护一个消费位置（Consumer Offset），这个位置之前的消息都被消费过，之后的消息都没有被消费过，每成功消费一条消息，消费位置就加一。这个消费位置是非常重要的概念，我们在使用消息队列的时候，丢消息的原因大多是由于消费位置处理不当导致的。

![RocketMQ 的消息模型](https://s2.ax1x.com/2019/10/27/KyRlct.png)

## Kafka 的消息模型
Kafka 的消息模型和 RocketMQ 是完全一样
的，所有 RocketMQ中对应的概念，和生产消费过程中的确认机制，都完全适用于 Kafka。唯一的区别是，在Kafka中，队列这个概念的名称不一样，Kafka 中对应的名称是“分区（Partition）”，含义和功能是没有任何区别的。