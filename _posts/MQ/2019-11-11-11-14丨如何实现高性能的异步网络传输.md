---
layout:     post
title:      "MQ-11-14丨如何实现高性能的异步网络传输"
date:       2019-11-11 18:04:00
author:     "jiefang"
header-style: text
tags:
    - MQ
---
# 11丨如何实现高性能的异步网络传输
![同步网络IO模型](https://s2.ax1x.com/2019/10/29/K222mq.png)

每个连接都需要阻塞一个线程来等待数据，大量的连接数就会需要相同数量的数据接
收线程。当这些 TCP 连接都在进行数据收发的时候，会导致什么情况呢？对，会有大量的线程来抢占 CPU 时间，造成频繁的 CPU 上下文切换，导致 CPU 的负载升高，整个系统的性能就会比较慢。
## 使用 Netty 来实现异步网络通信
![异步网络IO模型](https://s2.ax1x.com/2019/10/29/K22HXR.png)
## 使用 NIO 来实现异步网络通信
![NIO上线异步网络](https://s2.ax1x.com/2019/10/29/K2RwuR.png)

# 12丨序列化与反序列化
**要想使用网络框架的 API 来传输结构化的数据，必须得先实现结构化的数据与字
节流之间的双向转换**。这种将结构化数据转换成字节流的过程，我们称为序列化，反过来转换，就是反序列化。

序列化的用途除了用于在网络上传输数据以外，另外的一个重要用途是，将结构化数据保存在文件中，因为在文件内保存数据的形式也是二进制序列，和网络传输过程中的数据是一样的，所以序列化同样适用于将结构化数据保存在文件中。

## 该选择哪种序列化实现？
面对这么多种序列化实现，我们该如何选择呢？需要权衡几个因素：
- 序列化后的数据最好是易于人类阅读的；
- 实现的复杂度是否足够低；
- 序列化和反序列化的速度越快越好；
- 序列化后的信息密度越大越好，也就是说，同样的一个结构化数据，序列化之后占用的存储空间越小越好；

像 JSON、XML 这些序列化方法，可读性最好，但信息密度也最低。像Kryo、Hessian 这些通用的二进制序列化实现，适用范围广，使用简单，性能比 JSON、XML 要好一些，但是肯定不如专用的序列化实现。

## 实现高性能的序列化和反序列化

# 13丨传输协议：应用程序之间对话的语言
**传输协议就是应用程序之间对话的语言**
## 断句
- 分隔符
- 前置长度
## 用双工收发协议提升吞吐量
- 使用 ID 来标识请求与响应对应关系

发送请求的时候，给每个请求加一个序号，这个序号在本次会话内保证唯一，然后在响应中带上请求的序号，这样就可以把请求和响应对应上了。

# 14丨内存管理：如何避免内存溢出和频繁的垃圾回收