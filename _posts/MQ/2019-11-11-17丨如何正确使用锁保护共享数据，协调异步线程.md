---
layout:     post
title:      "MQ-17丨如何正确使用锁保护共享数据，协调异步线程"
date:       2019-11-11 18:06:18
author:     "jiefang"
header-style: text
tags:
    - MQ
---
# 17丨如何正确使用锁保护共享数据，协调异步线程

锁的原理是这样的：**任何时间都只能有一个线程持有锁，只有持有锁的线程才能访问被锁保护的资源**。

## 避免滥用锁
那是不是遇到这种情况都要用锁解决呢？我分享一下我个人使用锁的第一条原则：**如果能不用锁，就不用锁；如果你不确定是不是应该用锁，那也不要用锁**。

**只有在并发环境中，共享资源不支持并发访问，或者说并发访问共享资源会导致系统错误的情况下，才需要使用锁**。

## 锁的用法
- 在访问共享资源之前，先获取锁
- 如果获取锁成功，就可以访问共享资源了
- 最后，需要释放锁，以便其他线程继续访问共享资源

注意:
- 使用完锁，一定要释放它
- 避免死锁

## 如何避免死锁？
- 避免滥用锁，程序里用的锁少，写出死锁 Bug 的几率自然就低。
- 对于同一把锁，加锁和解锁必须要放在同一个方法中，这样一次加锁对应一次解锁，代码清晰简单，便于分析问题。
- 尽量避免在持有一把锁的情况下，去获取另外一把锁，就是要尽量避免同时持有多把锁。
- 如果需要持有多把锁，一定要注意加解锁的顺序，解锁的顺序要和加锁顺序相反
- 程序中所有的锁排一个顺序，在所有需要加锁的地方，按照同样的顺序加解锁

# 18丨 如何用硬件同步原语（CAS）替代锁？
## 什么是硬件同步原语？
**硬件同步原语**（Atomic Hardware Primitives）是由计算机硬件提供的一组原子操作，我们比较常用的原语主要是 CAS 和 FAA 这两种。

CAS（Compare and Swap）：先比较一下变量 p 当前的值是不是等于 old，如果等于，那就把变量 p 赋值为 new，并返回 true，否则就不改变变量 p，并返回 false。

FAA（Fetch and Add）：先获取变量 p 当前的值 value，然后给变量 p 增加 inc，最后返回变量 p 之前的值 value。
