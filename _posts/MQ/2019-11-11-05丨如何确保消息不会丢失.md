---
layout:     post
title:      "MQ-05丨如何确保消息不会丢失"
date:       2019-11-11 17:59:54
author:     "jiefang"
header-style: text
tags:
    - MQ
---
# 05丨如何确保消息不会丢失?
## 检测消息丢失的方法
**可以利用消息队列的有序性来验证是否有消息丢失**。原理非常简单，在 Producer 端，
给每个发出的消息附加一个连续递增的序号，然后在 Consumer 端来检查这个序号的
连续性。
有几个问题需要你注意:
- 像 Kafka 和 RocketMQ 这样的消息队列，它是不保证在 Topic 上的严格顺序的，
只能保证分区上的消息是有序的，所以我们在发消息的时候必须要指定分区，并且，在每个分区单独检测消息序号的连续性。
- 系统中 Producer 是多实例的，由于并不好协调多个 Producer 之间的发送顺序，
所以也需要每个 Producer 分别生成各自的消息序号，并且需要附加上 Producer 的标识，在 Consumer 端按照每个 Producer 分别来检测序号的连续性。
- Consumer 实例的数量最好和分区数量一致，做到 Consumer 和分区一一对应，这样会比
较方便地在 Consumer 内检测消息序号的连续性。

## 确保消息可靠传递
![消息的生产消费](https://s2.ax1x.com/2019/10/28/K64QtU.png)
- 生产阶段: 在这个阶段，从消息在 Producer 创建出来，经过网络传输发送到 Broker
端。
- 存储阶段: 在这个阶段，消息在Broker端存储，如果是集群，消息会在这个阶段被复制到其他的副本上。
- 消费阶段: 在这个阶段，Consumer 从 Broker 上拉取消息，经过网络传输发送到
Consumer 上。

### 生产阶段
在生产阶段，消息队列通过最常用的请求确认机制，来保证消息的可靠传递：当你的代码调用发消息方法时，消息队列的客户端会把消息发送到 Broker，Broker 收到消息后，会给客户端返回一个确认响应，表明消息已经收到了。客户端收到响应后，完成了一次正常消息的发送。

只要 Producer 收到了 Broker 的确认响应，就可以保证消息在生产阶段不会丢失。
**你在编写发送消息代码时，需要注意，正确处理返回值或者捕获异常，就可以保证这个阶段的消息不会丢失。**
以 Kafka 为例，我们看一下如何可靠地发送消息：
```
try {
    RecordMetadata metadata = producer.send(record).get();
    System.out.println(" 消息发送成功。");
}catch (Throwable e) {
    System.out.println(" 消息发送失败！");
    System.out.println(e);
}
```
异步发送时，则需要在回调方法里进行检查。这个地方是需要特别注意的，很多丢消息的原因就是，我们使用了异步发送，却没有在回调中检查发送结果。
```
producer.send(record, (metadata, exception) -> {
    if (metadata != null) {
        System.out.println(" 消息发送成功。");
    }else {
        System.out.println(" 消息发送失败！");
        System.out.println(exception);
    }
});
```

### 存储阶段
在存储阶段正常情况下，只要Broker在正常运行，就不会出现丢失消息的问题，但是如果Broker 出现了故障，比如进程死掉了或者服务器宕机了，还是可能会丢失消息的。
**如果对消息的可靠性要求非常高，可以通过配置 Broker 参数来避免因为宕机丢消息。**

对于单个节点的 Broker，需要配置Broker参数，在收到消息后，将消息写入磁盘后再给Producer 返回确认响应，这样即使发生宕机，由于消息已经被写入磁盘，就不会丢失消
息，恢复后还可以继续消费。例如，在 RocketMQ 中，需要将**刷盘方式 flushDiskType 配置为SYNC_FLUSH同步刷盘**。

如果是 Broker 是由多个节点组成的集群，需要将Broker集群配置成：**至少将消息发送到2 个以上的节点，再给客户端回复发送确认响应**。这样当某个Broker宕机时，其他的Broker 可以替代宕机的 Broker，也不会发生消息丢失。
### 消费阶段
消费阶段采用和生产阶段类似的确认机制来保证消息的可靠传递，客户端从 Broker 拉取消息后，执行用户的消费业务逻辑，成功后，才会给Broker发送消费确认响应。如果Broker 没有收到消费确认响应，下次拉消息的时候还会返回同一条消息，确保消息不会在网络传输过程中丢失，也不会因为客户端在执行消费逻辑中出错导致丢失。

在编写消费代码时需注意：**不要在收到消息后就立即发送消费确认，而是应该在执
行完所有消费业务逻辑之后，再发送消费确认**。

## 小结
- 在生产阶段，你需要捕获消息发送的错误，并重发消息。
- 在存储阶段，你可以通过配置刷盘和复制相关的参数，让消息写入到多个副本的磁盘上，来确保消息不会因为某个 Broker 宕机或者磁盘损坏而丢失。
- 在消费阶段，你需要在处理完全部消费业务逻辑之后，再发送消费确认。