---
layout:     post
title:      "Java多线程-05丨内存屏障"
date:       2019-10-30 00:00:00
author:     "jiefang"
header-style: text
tags:
    - Java多线程
    - JVM
---
# 内存屏障
> 内存屏障（Memory Barrier）与内存栅栏（Memory Fence）是同一个概念，不同的叫法。

## 内存栅栏
X86平台来说，有几种主要的内存屏障：
- `lfence`，是一种`Load Barrier` 读屏障。在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据
- `sfence`, 是一种`Store Barrier` 写屏障。在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存
- `mfence`, 是一种全能型的屏障，具备`ifence`和`sfence`的能力
- Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。

Lock前缀实现了类似的能力:
- 它先对总线/缓存加锁，然后执行后面的指令，最后释放锁后会把高速缓存中的脏数据全部刷新回主内存。
- 在Lock锁住总线的时候，其他CPU的读写请求都会被阻塞，直到锁释放。Lock后的写操作会让其他CPU相关的cache line失效，从而从新从内存加载最新的数据。这个是通过缓存一致性协议(MESI)做的。

## 标准
两个指令：
- **Store屏障**：将处理器缓存的数据刷新到内存中。Store屏障的作用是执行flush处理器缓存的操作，说白了就是把自己当前处理器更新的变量的值，都刷新到高速缓存（或者主内存）里去。
- **Load屏障**：将内存存储的数据拷贝到处理器的缓存中。Load屏障的作用是执行refresh处理器缓存的操作，说白了就是对别的处理器更新过的变量，从其他处理器的高速缓存（或者主内存）加载数据到自己的高速缓存来，确保自己看到的是最新的数据。
- **Acquire屏障**：复合屏障，相当于LoadLoad屏障 + LoadStore屏障；
- **Release屏障**：复合屏障，相当于StoreLoad屏障 + StoreStore屏障；

| 屏障类型  |指令示例|说明|
|---|---|---|
|`LoadLoad Barriers`  |Load1;`LoadLoad`;Load2|该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作|
|`StoreStore Barriers`|Store1;`StoreStore`;Store2|该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作|
|`LoadStore Barriers` |Load1;`LoadStore`;Store2|确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作|
|`StoreLoad Barriers` |Store1;`StoreLoad`;Load2|该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作。它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令|

`StoreLoad Barriers`同时具备其他三个屏障的效果，因此也称之为全能屏障（`mfence`），是目前大多数处理器所支持的；但是相对其他屏障，该屏障的开销相对昂贵。

## 内存屏障在Java中的体现

### volatile

- `volatile`写之前，所有变量的读写操作都已完成。
- `volatile`写之后，`volatile`变量读写操作都不会重排序到其前面。
- `volatile`读之后，所有变量读写操作都不会重排序到其前面。
- `volatile`读之前，所有`volatile`读写操作都已完成。

JMM 内存屏障插入策略：
- 在每个 `volatile` 写操作的前面插入一个 `StoreStore` 屏障。
- 在每个 `volatile` 写操作的后面插入一个 `StoreLoad` 屏障。
- 在每个 `volatile` 读操作的后面插入一个 `LoadLoad` 屏障。
- 在每个 `volatile` 读操作的后面插入一个 `LoadStore` 屏障。

### final
编译器会在 final 域的写之后，构造函数 return 之前，插入一个 **`StoreStore` 屏障**。这个屏障禁止处理器把final域的写重排序到构造函数之外。
### CAS
在CPU架构中依靠lock信号保证可见性并禁止重排序。
lock前缀是一个特殊的信号，执行过程如下：

- 对总线和缓存上锁。
- 强制所有lock信号之前的指令，都在此之前被执行，并同步相关缓存。
- 执行lock后的指令（如cmpxchg）。
- 释放对总线和缓存上的锁。
- 强制所有lock信号之后的指令，都在此之后被执行，并同步相关缓存。

因此，lock信号虽然不是内存屏障，但具有mfence的语义（当然，还有排他性的语义）。
与内存屏障相比，lock信号要额外对总线和缓存上锁，成本更高。

### Monitor锁
JVM的内置锁通过操作系统的管程实现。由于管程是一种互斥资源，修改互斥资源至少需要一个CAS操作。因此，锁必然也使用了lock信号，具有mfence的语义。

```
int b = 0;
int c = 0;
synchronized(this) { -> monitorenter
	Load内存屏障
	Acquire内存屏障
    int a = b;
    c = 1; => synchronized代码块里面还是可能会发生指令重排
	Release内存屏障
} -> monitorexit
Store内存屏障
```

#### 原子性

加锁和释放锁，基于ObjectMonitor实现。

#### 可见性

- 在monitorexit指令之后，会有一个Store屏障，让线程把自己在同步代码块里修改的变量的值都执行flush处理器缓存的操作，刷到高速缓存（或者主内存）里去；
- 然后在monitorenter指令之后会加一个Load屏障，执行refresh处理器缓存的操作，把别的处理器修改过的最新值加载到自己高速缓存里来；

所以说通过Load屏障和Store屏障，就可以让synchronized保证可见性

#### 有序性

- 在monitorenter指令之后，Load屏障之后，会加一个Acquire屏障，这个屏障的作用是禁止读操作和读写操作之间发生指令重排序。
- 在monitorexit指令之前，会加一个Release屏障，这个屏障的作用是禁止写操作和读写操作之间发生重排序。

所以说，通过 Acquire屏障和Release屏障，就可以让synchronzied保证有序性，只有synchronized内部的指令可以重排序，但是绝对不会跟外部的指令发生重排序。





[内存屏障](https://preshing.com/20120710/memory-barriers-are-like-source-control-operations/)

[内存屏障](https://preshing.com/20120913/acquire-and-release-semantics/)

[volatile与内存屏障总结](https://zhuanlan.zhihu.com/p/43526907)

